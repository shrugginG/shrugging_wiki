## 字符，字符集，字符编码

### 字符

各种文字和符号的总称，包括各国家文字、标点符号、图形符号、数字等。 也就是说，它是一个信息单位，一个数字是一个字符，一个文字是一个字符，一个标点符号也是一个字符。

### 字节

字节是一个8bit的存储单元，取值范围是0x00~0xFF。 根据字符编码的不同，一个字符可以是单个字节的，也可以是多个字节的。

### 字符集

字符的集合就叫字符集。不同集合支持的字符范围自然也不一样，譬如ASCII只支持英文，GB18030支持中文等等

在字符集中，有一个码表的存在，每一个字符在各自的字符集中对应着一个唯一的码。但是同一个字符在不同字符集中的码是不一样的，譬如字符“中”在Unicode和GB18030中就分别对应着不同的码(`20013`与`54992`)。

### 字符编码

定义字符集中的字符如何编码为特定的二进制数，以便在计算机中存储。 字符集和字符编码一般一一对应(有例外)

譬如GB18030既可以代表字符集，也可以代表对应的字符编码，它为了兼容`ASCII码`，编码方式为code大于`255`的采用两位字节(或4字节)来代表一个字符，否则就是兼容模式，一个字节代表一个字符。(简单一点理解，将它认为是现在用的的中文编码就行了)

字符集与字符编码的一个例外就是Unicode字符集，它有多种编码实现(UTF-8,UTF-16,UTF-32等)

## 简要介绍

下面举些示例方便快速理解。

### 字符集与字符编码的快速区分

- ASCII码是一个字符集，同时它的实现也只有一种，因此它也可以指代这个字符集对应的字符编码
- GB18030是一个字符集，主要是中国人为了解决中文而发明制定的，由于它的实现也只有一种，所以它也可以指代这个字符集对应的字符编码
- Unicode是一个字符集，为了解决不同字符集码表不一致而推出的，统一了所有字符对应的码，因此在这个规范下，所有字符对应的码都是一致的(统一码)，但是统一码只规定了字符与码表的一一对应关系，却没有规定该如何实现，因此这个字符集有多种实现方式(UTF-8,UTF-18,UTF-32)，因此这些实现就是对应的字符编码。 也就是说，Unicode统一约定了字符与码表直接一一对应的关系，而UTF-8是Unicode字符集的一种字符编码实现方式，它规定了字符该如何编码成二进制，存储在计算机中。

### 字符集与字符编码发展简史

这段资料主要借鉴了参考链接中的描述，只对大概发展做一个简要概述，每一个编码的详细介绍请参考系列文章目录里的其它文章。

#### 欧美的单字节字符编码发展

- 美国人发明了计算机，使用的是英文，所以一开始就设计了一个几乎只支持英文的字符集`ASCII码`(1963 发布)，有128个码位，用一个字节即可表示，范围为`00000000-01111111`
- 后来发现码位不够，于是在这基础上进行拓展，256个字符，取名为`EASCII(Extended ASCII)`，也能一个字节表示，范围为`00000000-11111111`
- 后来传入欧洲，发现这个标准并不适用于一些欧洲语言，于是在`ASCII`(最原始的ASCII)的基础上拓展，形成了ISO-8859标准(国际标准，1998年发布)，跟EASCII类似，兼容ASCII。然后，根据欧洲语言的复杂特性，结合各自的地区语言形成了N个子标准，`ISO-8859-1、ISO-8859-2、...`。 兼容性简直令人发指。

#### 亚洲，只能双字节了

- 计算机传入亚洲后，国际标准已被完全不够用，东亚语言随便一句话就已经超出范围了，也是这时候亚洲各个国家根据自己的地区特色，有发明了自己地图适用的字符集与编码，譬如中国大陆的GB2312，中国台湾的BIG5，日本的Shift JIS等等 这些编码都是用双字节来进行存储，它们对外有一个统称(ANSI-American National Standards Institute)，也就是说GB2312或BIG5等都是ANSI在各自地区的不同标准。

#### Unicode，一统天下

- 到了全球互联网时代，不同国家，不同地区需要进行交互，这时候由于各自编码标准都不一样，彼此之间都是乱码，无法良好的沟通交流，于是这时候ISO组织与统一码联盟分别推出了UCS(Universal Multiple-Octet Coded Character Set)与Unicode。后来，两者意识到没有必要用两套字符集，于是进行了一次整合，到了Unicode2.0时代，Nnicode的编码和UCS的编码都基本一致(所以后续为了简便会同意用Unicode指代)，这时候所有的字符都可以采用同一个字符集，有着相同的编码，可以愉快的进行交流了。
- 需要注意的是UCS标准有自己的格式，如UCS-2(双字节)，UCS-4(四字节)等等 而Unicode也有自己的不同编码实现，如UTF-8，UTF-16，UTF-32等等 其中UTF-16可以认为是UCS-2的拓展，UTF-32可以认为是UCS-4的拓展，而Unicode可以认为是Unicode最终用来制霸互联网的一种编码格式。

#### 在中国，GB系列的发展

- 在计算机传入中国后，1980年，中国国家标准总局发布了第一个汉字编码国家标准GB2312(2312是标准序号)，采用双字节编码，里面包括了大部分汉字，拉丁字母，日文假名以及全角字符等。
- 然而，随着程序的发展，逐渐发现GB2312已经不满足需求了，于是1993年又推出了一个GBK编码(汉字国标扩展码)，完全兼容GB2312标准。并且包括了BIG5的所有汉字（繁体），于1995年发布。 同时GBK也涵盖了Unicode所有CJK汉字，所以也可以和Unicode做一一对应。
- 后来到了2000年，又推出了一个全新的标准 GB 18030，它不仅拓展了新的字符，如支持中国少数名族文字等，而且它采用了单字节，双字节，四字节三种编码方式，所以完全兼容ASCII码与GBK码。 到了2005年，这一标准有进行了拓展，推出了GB18030-2005，剧本涵盖所有汉字，也就是说，现在使用的国标标准码就是GB18030-2005了。

### 不同字符编码的字符是如何进行转换的

- 如果是相同字符集，由于相同字符集中的码都是一样的，所以只需要针对不同的编码方式转变而已。譬如UTF-16转UTF-8，首先会取到当前需要转换的字符的Unicode码，然后将当前的编码方式由双字节(有4字节的拓展就不赘述了)，变为变长的1，2，3等字节
- 如果是不同的字符集，由于不同字符集的码是不一样的，所以需要各自的码表才能进行转换。譬如UTF-16转GBK，首先需要取到当前需要转换的字符的Unicode码，然后根据Unicode和GBK码表一一对应的关系(只有部分共同都有的字符才能在码表中查到)，找到它对应的GBK码，然后用GBK的编码方式(双字节)进行编码

### 编年史

**注意，此编年史引用自来源链接中的内容(做了部分修改与更新)-http://www.jianshu.com/p/bd7a6c508c33**

- ASCII 1960 开发 1963 发布 1986 最后一次更新
- ISO-8859-1 1998 发布
- GB2312 1980 发布
- GBK 1993 发布
- GB18030 2000年3月17日发布 GB18030-2000 2001年的1月强制执行GB18030-2000 2005年发布GB18030-2005
- UCS与Unicode 1984年 UCS开始制定标准 1991年10月 Unicode1.0发布 1992年1月 Unicode与ISO 10646国际编码标准正式合作，发展一套通用 编码标准 1993年 ISO组织发表UCS(标准编号ISO 10646)国际编码标准的第一个版 本 1993年6月 修订了Unicode 1.0，发布Unicode 1.1 1996 年7月 发布Unicode2.0(实现了代理机制（UTF-16），这时候Unicode和UCS可以近似认为一样
- UTF-16 1996年7月 发布
- UTF-8 1993 发布 1996年 微软的CAB（MS Cabinet）在UTF-8标准正式落实前就明确容许在任何地方使用UTF-8编码系统 2008 流行

## ASCII

在计算机内部，所有的信息最终都表示为一个二进制的字符串。每一个二进制位（bit）有0和1两种状态，因此八个二进制位就可以组合出256种状态（-128~127），这被称为一个字节（byte）。也就是说，一个字节一共可以用来表示256种不同的状态，每一个状态对应一个符号，就是256个符号，从0000000到11111111。
**上个世纪60年代，美国制定了一套字符编码，对英语字符与二进制位之间的关系，做了统一规定。这被称为ASCII码，一直沿用至今。**
**ASCII码一共规定了128个字符的编码，比如空格“SPACE”是32（二进制00100000），大写的字母A是65（二进制01000001）。这128个符号（包括32个不能打印出来的控制符号），只占用了一个字节的后面7位，最前面的1位统一规定为0。**

ASCII码用了1个字节，1个字节可以表示256种状态，但ASCII码只用了128种，也就是一个字节的后七位，最前面的1位都是0。

### ASCII对照表

#### ASCII控制字符

| 二进制    | 十进制 | 十六进制 | 缩写 | 可以显示的表示法 | 名称/意义                           |
| --------- | ------ | -------- | ---- | ---------------- | ----------------------------------- |
| 0000 0000 | 0      | 00       | NUL  | ␀                | 空字符（Null）                      |
| 0000 0001 | 1      | 01       | SOH  | ␁                | 标题开始                            |
| 0000 0010 | 2      | 02       | STX  | ␂                | 本文开始                            |
| 0000 0011 | 3      | 03       | ETX  | ␃                | 本文结束                            |
| 0000 0100 | 4      | 04       | EOT  | ␄                | 传输结束                            |
| 0000 0101 | 5      | 05       | ENQ  | ␅                | 请求                                |
| 0000 0110 | 6      | 06       | ACK  | ␆                | 确认回应                            |
| 0000 0111 | 7      | 07       | BEL  | ␇                | 响铃                                |
| 0000 1000 | 8      | 08       | BS   | ␈                | 退格                                |
| 0000 1001 | 9      | 09       | HT   | ␉                | 水平定位符号                        |
| 0000 1010 | 10     | 0A       | LF   | ␊                | 换行键                              |
| 0000 1011 | 11     | 0B       | VT   | ␋                | 垂直定位符号                        |
| 0000 1100 | 12     | 0C       | FF   | ␌                | 换页键                              |
| 0000 1101 | 13     | 0D       | CR   | ␍                | 归位键                              |
| 0000 1110 | 14     | 0E       | SO   | ␎                | 取消变换（Shift out）               |
| 0000 1111 | 15     | 0F       | SI   | ␏                | 启用变换（Shift in）                |
| 0001 0000 | 16     | 10       | DLE  | ␐                | 跳出数据通讯                        |
| 0001 0001 | 17     | 11       | DC1  | ␑                | 设备控制一（XON 启用软件速度控制）  |
| 0001 0010 | 18     | 12       | DC2  | ␒                | 设备控制二                          |
| 0001 0011 | 19     | 13       | DC3  | ␓                | 设备控制三（XOFF 停用软件速度控制） |
| 0001 0100 | 20     | 14       | DC4  | ␔                | 设备控制四                          |
| 0001 0101 | 21     | 15       | NAK  | ␕                | 确认失败回应                        |
| 0001 0110 | 22     | 16       | SYN  | ␖                | 同步用暂停                          |
| 0001 0111 | 23     | 17       | ETB  | ␗                | 区块传输结束                        |
| 0001 1000 | 24     | 18       | CAN  | ␘                | 取消                                |
| 0001 1001 | 25     | 19       | EM   | ␙                | 连接介质中断                        |
| 0001 1010 | 26     | 1A       | SUB  | ␚                | 替换                                |
| 0001 1011 | 27     | 1B       | ESC  | ␛                | 跳出                                |
| 0001 1100 | 28     | 1C       | FS   | ␜                | 文件分割符                          |
| 0001 1101 | 29     | 1D       | GS   | ␝                | 组群分隔符                          |
| 0001 1110 | 30     | 1E       | RS   | ␞                | 记录分隔符                          |
| 0001 1111 | 31     | 1F       | US   | ␟                | 单元分隔符                          |
| 0111 1111 | 127    | 7F       | DEL  | ␡                | 删除                                |

#### ASCII可显示字符
| 二进制    | 十进制 | 十六进制 | 图形        |
| --------- | ------ | -------- | ----------- |
| 0010 0000 | 32     | 20       | （空格）(␠) |
| 0010 0001 | 33     | 21       | !           |
| 0010 0010 | 34     | 22       | "           |
| 0010 0011 | 35     | 23       | #           |
| 0010 0100 | 36     | 24       | $           |
| 0010 0101 | 37     | 25       | %           |
| 0010 0110 | 38     | 26       | &           |
| 0010 0111 | 39     | 27       | '           |
| 0010 1000 | 40     | 28       | (           |
| 0010 1001 | 41     | 29       | )           |
| 0010 1010 | 42     | 2A       | *           |
| 0010 1011 | 43     | 2B       | +           |
| 0010 1100 | 44     | 2C       | ,           |
| 0010 1101 | 45     | 2D       | -           |
| 0010 1110 | 46     | 2E       | .           |
| 0010 1111 | 47     | 2F       | /           |
| 0011 0000 | 48     | 30       | 0           |
| 0011 0001 | 49     | 31       | 1           |
| 0011 0010 | 50     | 32       | 2           |
| 0011 0011 | 51     | 33       | 3           |
| 0011 0100 | 52     | 34       | 4           |
| 0011 0101 | 53     | 35       | 5           |
| 0011 0110 | 54     | 36       | 6           |
| 0011 0111 | 55     | 37       | 7           |
| 0011 1000 | 56     | 38       | 8           |
| 0011 1001 | 57     | 39       | 9           |
| 0011 1010 | 58     | 3A       | :           |
| 0011 1011 | 59     | 3B       | ;           |
| 0011 1100 | 60     | 3C       | <           |
| 0011 1101 | 61     | 3D       | =           |
| 0011 1110 | 62     | 3E       | >           |
| 0011 1111 | 63     | 3F       | ?           |
| 0100 0000 | 64   | 40   | @    |
| 0100 0001 | 65   | 41   | A    |
| 0100 0010 | 66   | 42   | B    |
| 0100 0011 | 67   | 43   | C    |
| 0100 0100 | 68   | 44   | D    |
| 0100 0101 | 69   | 45   | E    |
| 0100 0110 | 70   | 46   | F    |
| 0100 0111 | 71   | 47   | G    |
| 0100 1000 | 72   | 48   | H    |
| 0100 1001 | 73   | 49   | I    |
| 0100 1010 | 74   | 4A   | J    |
| 0100 1011 | 75   | 4B   | K    |
| 0100 1100 | 76   | 4C   | L    |
| 0100 1101 | 77   | 4D   | M    |
| 0100 1110 | 78   | 4E   | N    |
| 0100 1111 | 79   | 4F   | O    |
| 0101 0000 | 80   | 50   | P    |
| 0101 0001 | 81   | 51   | Q    |
| 0101 0010 | 82   | 52   | R    |
| 0101 0011 | 83   | 53   | S    |
| 0101 0100 | 84   | 54   | T    |
| 0101 0101 | 85   | 55   | U    |
| 0101 0110 | 86   | 56   | V    |
| 0101 0111 | 87   | 57   | W    |
| 0101 1000 | 88   | 58   | X    |
| 0101 1001 | 89   | 59   | Y    |
| 0101 1010 | 90   | 5A   | Z    |
| 0101 1011 | 91   | 5B   | [    |
| 0101 1100 | 92   | 5C   | \    |
| 0101 1101 | 93   | 5D   | ]    |
| 0101 1110 | 94   | 5E   | ^    |
| 0101 1111 | 95   | 5F   | _    |
| 0110 0000 | 96   | 60   | `    |
| 0110 0001 | 97   | 61   | a    |
| 0110 0010 | 98   | 62   | b    |
| 0110 0011 | 99   | 63   | c    |
| 0110 0100 | 100  | 64   | d    |
| 0110 0101 | 101  | 65   | e    |
| 0110 0110 | 102  | 66   | f    |
| 0110 0111 | 103  | 67   | g    |
| 0110 1000 | 104  | 68   | h    |
| 0110 1001 | 105  | 69   | i    |
| 0110 1010 | 106  | 6A   | j    |
| 0110 1011 | 107  | 6B   | k    |
| 0110 1100 | 108  | 6C   | l    |
| 0110 1101 | 109  | 6D   | m    |
| 0110 1110 | 110  | 6E   | n    |
| 0110 1111 | 111  | 6F   | o    |
| 0111 0000 | 112  | 70   | p    |
| 0111 0001 | 113  | 71   | q    |
| 0111 0010 | 114  | 72   | r    |
| 0111 0011 | 115  | 73   | s    |
| 0111 0100 | 116  | 74   | t    |
| 0111 0101 | 117  | 75   | u    |
| 0111 0110 | 118  | 76   | v    |
| 0111 0111 | 119  | 77   | w    |
| 0111 1000 | 120  | 78   | x    |
| 0111 1001 | 121  | 79   | y    |
| 0111 1010 | 122  | 7A   | z    |
| 0111 1011 | 123  | 7B   | {    |
| 0111 1100 | 124  | 7C   | \|   |
| 0111 1101 | 125  | 7D   | }    |
| 0111 1110 | 126  | 7E   | ~    |

**GB类的汉字编码与后文的Unicode和UTF-8是毫无关系的。**



## Unicode编码

 

正如上一节所说，世界上存在着多种编码方式，同一个二进制数字可以被解释成不同的符号。因此，要想打开一个文本文件，就必须知道它的编码方式，否则用错误的编码方式解读，就会出现乱码。为什么电子邮件常常出现乱码？就是因为发信人和收信人使用的编码方式不一样。
可以想象，如果有一种编码，将世界上所有的符号都纳入其中。每一个符号都给予一个独一无二的编码，那么乱码问题就会消失。这就是Unicode，就像它的名字都表示的，这是一种所有符号的编码。

Unicode当然是一个很大的集合，现在的规模可以容纳100多万个符号。每个符号的编码都不一样，比如，U+0639表示阿拉伯字母Ain，U+0041表示英语的大写字母A，U+4E25表示汉字“严”。具体的符号对应表，可以查询unicode.org，或者专门的汉字对应表。

## Unicode的问题

需要注意的是，Unicode只是一个符号集，它只规定了符号的二进制代码，却没有规定这个二进制代码应该如何存储。
比如，汉字“严”的unicode是十六进制数4E25，转换成二进制数足足有15位（100111000100101），也就是说这个符号的表示至少需要2个字节。表示其他更大的符号，可能需要3个字节或者4个字节，甚至更多。
这里就有两个严重的问题，第一个问题是，如何才能区别unicode和ascii？计算机怎么知道三个字节表示一个符号，而不是分别表示三个符号呢？第二个问题是，我们已经知道，英文字母只用一个字节表示就够了，如果unicode统一规定，每个符号用三个或四个字节表示，那么每个英文字母前都必然有二到三个字节是0，这对于存储来说是极大的浪费，文本文件的大小会因此大出二三倍，这是无法接受的。

它们造成的结果是：1）出现了unicode的多种存储方式，也就是说有许多种不同的二进制格式，可以用来表示unicode。2）unicode在很长一段时间内无法推广，直到互联网的出现。

## UTF-8

 

互联网的普及，强烈要求出现一种统一的编码方式。UTF-8就是在互联网上使用最广的一种unicode的实现方式。其他实现方式还包括UTF-16和UTF-32，不过在互联网上基本不用。重复一遍，**这里的关系是，UTF-8是Unicode的实现方式之一。**
UTF-8最大的一个特点，就是它是一种变长的编码方式。它可以使用1~4个字节表示一个符号，根据不同的符号而变化字节长度。
UTF-8的编码规则很简单，只有二条：
1）对于单字节的符号，字节的第一位设为0，后面7位为这个符号的unicode码。因此对于英语字母，UTF-8编码和ASCII码是相同的。
2）对于n字节的符号（n>1），第一个字节的前n位都设为1，第n+1位设为0，后面字节的前两位一律设为10。剩下的没有提及的二进制位，全部为这个符号的unicode码。
下表总结了编码规则，字母x表示可用编码的位。

|Unicode符号范围(十六进制) | UTF-8编码方式（二进制）|
| ---------- | ---------- |
|0000 0000 - 0000 007F | 0xxxxxxx|
|0000 0080 - 0000 07FF | 110xxxxx 10xxxxxx|
|0000 0800 - 0000 FFFF | 1110xxxx 10xxxxxx 10xxxxxx|
|0001 0000 - 0010 FFFF | 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx|

已知“严”的unicode是4E25（100111000100101），根据上表，可以发现4E25处在第三行的范围内（0000 0800-0000 FFFF），因此“严”的UTF-8编码需要三个字节，即格式是“1110xxxx 10xxxxxx 10xxxxxx”。然后，从“严”的最后一个二进制位开始，依次从后向前填入格式中的x，多出的位补0。这样就得到了，“严”的UTF-8编码是“11100100 10111000 10100101”，转换成十六进制就是E4B8A5。

## Base64编码

### 简介

Base64是一种编码方式，通常用于将二进制数据编码为可打印字符组成的数据格式。

### 为什么要有Base64编码

在很久以前，发送邮件时只支持ASCII字符的发送，如果有非ASCII码字符，则发送不了，于是需要在不改变传统协议的情况下，做一种扩展方案来支持这类字符的传送。Base64编码应运而生。

### Base64的常见误区

很多开发者喜欢直接用Base64进行加密解密工作，实际上这个是完全无意义的，因为Base64这种编码规则是公开的，基本只要有程序能力都能解开，所以请勿用作加密用途。

Base64编码的主要的作用不在于安全性，而在于让内容能在网络间无错的传输。(常用语编码特殊字符，编码小型二进制文件等)

### 编码原理

- 将数据按照 3个8位字节一组的形式进行处理，每3个8位字节在编码之后被转换为4个6位字节
  - 即`3*8=24`变为`4*6=24`
  - 在编码后的6位的前面补两个0，形成8位一个字节的形式
  - 这样，编码后3个8位字节则自动转化成4个6位字节了
  - 原因是2的6次方为64，所以每6个位为一个单元，可以转换为对应64个字符中的某一个
- 当数据的长度无法满足3的倍数的情况下，最后的数据需要进行填充操作
  - 当原数据不是3的整数倍时，会自动补0。也就是说，如果原数据剩余1个字节，那么，另外两个都是补的0，如果剩余2个字节，另外一个字节补得0。
  - 然后编码时，对于后面自动补0的字符，会用`=`作为填充字符(这里`=`不是第65个字符，仅仅做填充作用)
- 之所以要用`=`号进行填充是为了解码时方便还原(因为`=`号只需要还原为`0`即可)

### 解码

- 解码是编码的逆过程
- 其中的`=`号还原为`0`即可

### 转码对照表

每6个单元高位补2个零形成的字节位于0~63之间，通过在转码表中查找对应的可打印字符。“=”用于填充。如下所示为转码表。

![img](https://raw.githubusercontent.com/shrugginG/MyImagesRepo/master/PicGO_images/3437876-ea79a939654e9fa6.jpg)



## 参考

https://dailc.github.io/2017/05/02/charsetSeries.html